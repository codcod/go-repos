
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repos: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/codcod/repos/cmd/repos/main.go (14.2%)</option>
				
				<option value="file1">github.com/codcod/repos/internal/config/config.go (100.0%)</option>
				
				<option value="file2">github.com/codcod/repos/internal/git/git.go (89.4%)</option>
				
				<option value="file3">github.com/codcod/repos/internal/git/remove.go (87.5%)</option>
				
				<option value="file4">github.com/codcod/repos/internal/github/pr.go (34.7%)</option>
				
				<option value="file5">github.com/codcod/repos/internal/runner/runner.go (87.5%)</option>
				
				<option value="file6">github.com/codcod/repos/internal/util/logging.go (100.0%)</option>
				
				<option value="file7">github.com/codcod/repos/internal/util/repo.go (100.0%)</option>
				
				<option value="file8">github.com/codcod/repos/internal/util/scan.go (90.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/codcod/repos/internal/config"
        "github.com/codcod/repos/internal/git"
        "github.com/codcod/repos/internal/github"
        "github.com/codcod/repos/internal/runner"
        "github.com/codcod/repos/internal/util"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        configFile  string
        tag         string
        parallel    bool
        logDir      string
        defaultLogs = "logs"

        // Version information - will be set via build flags or environment variables
        version = getEnvOrDefault("VERSION", "dev")
        commit  = getEnvOrDefault("COMMIT", "unknown")
        date    = getEnvOrDefault("BUILD_DATE", "unknown")

        // PR command flags
        prTitle    string
        prBody     string
        prBranch   string
        baseBranch string
        commitMsg  string
        prDraft    bool
        prToken    string
        createOnly bool

        // Init command flags
        maxDepth   int
        outputFile string
        overwrite  bool
)

// getEnvOrDefault returns the value of the environment variable or a default value
func getEnvOrDefault(key, defaultValue string) string <span class="cov10" title="18">{
        if value := os.Getenv(key); value != "" </span><span class="cov7" title="9">{
                return value
        }</span>
        <span class="cov7" title="9">return defaultValue</span>
}

var rootCmd = &amp;cobra.Command{
        Use:   "repos",
        Short: "A tool to manage multiple GitHub repositories",
        Long:  `Clone multiple GitHub repositories and run arbitrary commands inside them.`,
}

var cloneCmd = &amp;cobra.Command{
        Use:   "clone",
        Short: "Clone repositories specified in config",
        Long:  `Clone all repositories listed in the config file. Filter by tag if specified.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg, err := config.LoadConfig(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">repositories := cfg.FilterRepositoriesByTag(tag)
                if len(repositories) == 0 </span><span class="cov0" title="0">{
                        color.Yellow("No repositories found with tag: %s", tag)
                        return
                }</span>

                <span class="cov0" title="0">color.Green("Cloning %d repositories...", len(repositories))

                err = processRepos(repositories, parallel, func(r config.Repository) error </span><span class="cov0" title="0">{
                        err := git.CloneRepository(r)
                        // Only show "Successfully cloned" if no error AND repository didn't already exist
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // git.CloneRepository returns nil when repo exists (skipping clone) without showing success message
                        // We don't need to output additional success message here
                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">color.Green("Done cloning repositories")</span>
        },
}

var runCmd = &amp;cobra.Command{
        Use:   "run [command]",
        Short: "Run a command in each repository",
        Long:  `Execute an arbitrary command in each repository. Filter by tag if specified.`,
        Args:  cobra.MinimumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                command := args[0]
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        command = args[0] + " " + args[1]
                        for _, arg := range args[2:] </span><span class="cov0" title="0">{
                                command += " " + arg
                        }</span>
                }

                <span class="cov0" title="0">cfg, err := config.LoadConfig(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">repositories := cfg.FilterRepositoriesByTag(tag)
                if len(repositories) == 0 </span><span class="cov0" title="0">{
                        color.Yellow("No repositories found with tag: %s", tag)
                        return
                }</span>

                <span class="cov0" title="0">color.Green("Running '%s' in %d repositories...", command, len(repositories))

                // Create log directory if specified
                if logDir == "" </span><span class="cov0" title="0">{
                        logDir = defaultLogs
                }</span>

                // Absolute path for logs
                <span class="cov0" title="0">absLogDir, err := filepath.Abs(logDir)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error resolving log directory path: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">err = processRepos(repositories, parallel, func(r config.Repository) error </span><span class="cov0" title="0">{
                        return runner.RunCommand(r, command, absLogDir)
                }</span>)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">color.Green("Done running commands in all repositories")</span>
        },
}

var prCmd = &amp;cobra.Command{
        Use:   "pr",
        Short: "Create pull requests for repositories with changes",
        Long:  `Check for changes in repositories and create pull requests to GitHub.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg, err := config.LoadConfig(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">repositories := cfg.FilterRepositoriesByTag(tag)
                if len(repositories) == 0 </span><span class="cov0" title="0">{
                        color.Yellow("No repositories found with tag: %s", tag)
                        return
                }</span>

                <span class="cov0" title="0">color.Green("Checking %d repositories for changes...", len(repositories))

                // Use environment variable if token not provided via flag
                if prToken == "" </span><span class="cov0" title="0">{
                        prToken = os.Getenv("GITHUB_TOKEN")
                        if prToken == "" &amp;&amp; !createOnly </span><span class="cov0" title="0">{
                                color.Red("GitHub token not provided. Use --token flag or set GITHUB_TOKEN environment variable.")
                                os.Exit(1)
                        }</span>
                }

                // Configure PR options
                <span class="cov0" title="0">prOptions := github.PROptions{
                        Title:      prTitle,
                        Body:       prBody,
                        BranchName: prBranch,
                        BaseBranch: baseBranch,
                        CommitMsg:  commitMsg,
                        Draft:      prDraft,
                        Token:      prToken,
                        CreateOnly: createOnly,
                }

                successCount := 0

                err = processRepos(repositories, parallel, func(r config.Repository) error </span><span class="cov0" title="0">{
                        if err := github.CreatePullRequest(r, prOptions); err != nil </span><span class="cov0" title="0">{
                                if strings.Contains(err.Error(), "no changes detected") </span><span class="cov0" title="0">{
                                        color.Yellow("%s | No changes detected", color.New(color.FgCyan, color.Bold).SprintFunc()(r.Name))
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                color.Green("%s | Pull request created successfully", color.New(color.FgCyan, color.Bold).SprintFunc()(r.Name))
                                successCount++
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">color.Green("Created %d pull requests", successCount)</span>
        },
}

var rmCmd = &amp;cobra.Command{
        Use:   "rm",
        Short: "Remove cloned repositories",
        Long:  `Remove repositories that were previously cloned. Filter by tag if specified.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg, err := config.LoadConfig(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">repositories := cfg.FilterRepositoriesByTag(tag)
                if len(repositories) == 0 </span><span class="cov0" title="0">{
                        color.Yellow("No repositories found with tag: %s", tag)
                        return
                }</span>

                <span class="cov0" title="0">color.Green("Removing %d repositories...", len(repositories))

                err = processRepos(repositories, parallel, func(r config.Repository) error </span><span class="cov0" title="0">{
                        if err := git.RemoveRepository(r); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">color.Green("%s | Successfully removed", color.New(color.FgCyan, color.Bold).SprintFunc()(r.Name))
                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">color.Green("Done removing repositories")</span>
        },
}

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Create a config.yaml file from discovered Git repositories",
        Long:  `Scan the current directory for Git repositories and generate a config.yaml file based on discovered repositories.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Get current directory
                currentDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error getting current directory: %v", err)
                        os.Exit(1)
                }</span>

                // Check if output file already exists
                <span class="cov0" title="0">if _, err := os.Stat(outputFile); err == nil &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                        color.Red("File %s already exists. Use --overwrite to replace it.", outputFile)
                        os.Exit(1)
                }</span>

                // Find Git repositories
                <span class="cov0" title="0">color.Green("Scanning for Git repositories in %s (max depth: %d)...", currentDir, maxDepth)
                repos, err := util.FindGitRepositories(currentDir, maxDepth)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error scanning for repositories: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if len(repos) == 0 </span><span class="cov0" title="0">{
                        color.Yellow("No Git repositories found in %s", currentDir)
                        os.Exit(0)
                }</span>

                <span class="cov0" title="0">color.Green("Found %d Git repositories", len(repos))

                // Create config structure
                cfg := config.Config{
                        Repositories: repos,
                }

                // Convert to YAML
                yamlData, err := yaml.Marshal(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error creating YAML: %v", err)
                        os.Exit(1)
                }</span>

                // Write to file
                <span class="cov0" title="0">err = os.WriteFile(outputFile, yamlData, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        color.Red("Error writing to file %s: %v", outputFile, err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">color.Green("Successfully created %s with %d repositories", outputFile, len(repos))

                // Print preview of the generated file
                fmt.Println("\nConfig file preview:")
                color.Cyan("---")
                fmt.Println(string(yamlData))</span>
        },
}

// Process repositories with clean error handling
func processRepos(repositories []config.Repository, parallel bool, processor func(config.Repository) error) error <span class="cov0" title="0">{
        logger := util.NewLogger()
        var hasErrors bool

        if parallel </span><span class="cov0" title="0">{
                var wg sync.WaitGroup
                var mu sync.Mutex
                wg.Add(len(repositories))

                for _, repo := range repositories </span><span class="cov0" title="0">{
                        go func(r config.Repository) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                if err := processor(r); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(r, "%v", err)
                                        mu.Lock()
                                        hasErrors = true
                                        mu.Unlock()
                                }</span>
                        }(repo)
                }

                <span class="cov0" title="0">wg.Wait()</span>
        } else<span class="cov0" title="0"> {
                for _, repo := range repositories </span><span class="cov0" title="0">{
                        if err := processor(repo); err != nil </span><span class="cov0" title="0">{
                                logger.Error(repo, "%v", err)
                                hasErrors = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if hasErrors </span><span class="cov0" title="0">{
                return fmt.Errorf("one or more commands failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov1" title="1">{
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "config.yaml", "config file path")
        rootCmd.PersistentFlags().StringVarP(&amp;tag, "tag", "t", "", "filter repositories by tag")
        rootCmd.PersistentFlags().BoolVarP(&amp;parallel, "parallel", "p", false, "execute operations in parallel")

        runCmd.Flags().StringVarP(&amp;logDir, "logs", "l", defaultLogs, "directory to store log files")

        // PR command flags
        prCmd.Flags().StringVar(&amp;prTitle, "title", "Automated changes", "Title for the pull request")
        prCmd.Flags().StringVar(&amp;prBody, "body", "This PR was created automatically", "Body text for the pull request")
        prCmd.Flags().StringVar(&amp;prBranch, "branch", "", "Branch name to create (default: automated-changes-{PID})")
        prCmd.Flags().StringVar(&amp;baseBranch, "base", "", "Base branch for the PR (default: main or master)")
        prCmd.Flags().StringVar(&amp;commitMsg, "message", "", "Commit message (defaults to PR title)")
        prCmd.Flags().BoolVar(&amp;prDraft, "draft", false, "Create PR as draft")
        prCmd.Flags().StringVar(&amp;prToken, "token", "", "GitHub token (can also use GITHUB_TOKEN env var)")
        prCmd.Flags().BoolVar(&amp;createOnly, "create-only", false, "Only create PR, don't commit changes")

        // Init command flags
        initCmd.Flags().IntVar(&amp;maxDepth, "depth", 3, "Maximum directory depth to scan for repositories")
        initCmd.Flags().StringVarP(&amp;outputFile, "output", "o", "config.yaml", "Output file name")
        initCmd.Flags().BoolVar(&amp;overwrite, "overwrite", false, "Overwrite existing file if it exists")

        rootCmd.AddCommand(cloneCmd)
        rootCmd.AddCommand(runCmd)
        rootCmd.AddCommand(prCmd)
        rootCmd.AddCommand(rmCmd)
        rootCmd.AddCommand(initCmd) // Add the init command

        // Add version command
        rootCmd.AddCommand(&amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("repos %s (%s) built on %s\n", version, commit, date)
                }</span>,
        })
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// Repository represents a GitHub repository configuration
type Repository struct {
        Name   string   `yaml:"name"`
        URL    string   `yaml:"url"`
        Tags   []string `yaml:"tags"`
        Path   string   `yaml:"path,omitempty"`   // Optional custom local path
        Branch string   `yaml:"branch,omitempty"` // Optional branch to clone
}

// Config represents the application configuration
type Config struct {
        Repositories []Repository `yaml:"repositories"`
}

// LoadConfig loads the configuration from a YAML file
func LoadConfig(path string) (*Config, error) <span class="cov5" title="7">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov5" title="6">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov4" title="5">return &amp;config, nil</span>
}

// FilterRepositoriesByTag filters repositories by tag
func (c *Config) FilterRepositoriesByTag(tag string) []Repository <span class="cov5" title="8">{
        if tag == "" </span><span class="cov2" title="2">{
                return c.Repositories
        }</span>

        <span class="cov5" title="6">var filtered []Repository
        for _, repo := range c.Repositories </span><span class="cov8" title="22">{
                for _, t := range repo.Tags </span><span class="cov10" title="45">{
                        if t == tag </span><span class="cov4" title="4">{
                                filtered = append(filtered, repo)
                                break</span>
                        }
                }
        }

        <span class="cov5" title="6">return filtered</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package git

import (
        "bytes"
        "fmt"
        "os"
        "os/exec"

        "github.com/codcod/repos/internal/config"
        "github.com/codcod/repos/internal/util"
)

// CloneRepository clones a repository
func CloneRepository(repo config.Repository) error <span class="cov4" title="2">{
        logger := util.NewLogger()

        // Determine target directory
        targetDir := util.GetRepoDir(repo)

        // Check if directory already exists
        if _, err := os.Stat(targetDir); err == nil </span><span class="cov1" title="1">{
                logger.Warn(repo, "Repository directory already exists, skipping")
                return nil
        }</span>

        // Clone the repository
        <span class="cov1" title="1">args := []string{"clone"}

        // Add branch flag if a branch is specified
        if repo.Branch != "" </span><span class="cov0" title="0">{
                args = append(args, "-b", repo.Branch)
        }</span>

        // Add repository URL and target directory
        <span class="cov1" title="1">args = append(args, repo.URL, targetDir)

        cmd := exec.Command("git", args...)

        var stdoutBuf, stderrBuf bytes.Buffer
        cmd.Stdout = &amp;stdoutBuf
        cmd.Stderr = &amp;stderrBuf

        // Print which branch is being cloned
        if repo.Branch != "" </span><span class="cov0" title="0">{
                logger.Info(repo, "Cloning branch '%s' from %s", repo.Branch, repo.URL)
        }</span> else<span class="cov1" title="1"> {
                logger.Info(repo, "Cloning default branch from %s", repo.URL)
        }</span>

        <span class="cov1" title="1">err := cmd.Run()

        if stdoutBuf.Len() &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%s | %s", repo.Name, stdoutBuf.String())
        }</span>

        <span class="cov1" title="1">if stderrBuf.Len() &gt; 0 </span><span class="cov1" title="1">{
                logger.Error(repo, "%s", stderrBuf.String())
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        // Only log success if we actually cloned
        <span class="cov0" title="0">logger.Success(repo, "Successfully cloned")
        return nil</span>
}

// RunGitCommand runs a git command in the repository directory
func RunGitCommand(dir string, args ...string) ([]byte, error) <span class="cov10" title="8">{
        cmd := exec.Command("git", args...)
        cmd.Dir = dir
        return cmd.Output()
}</span>

// HasChanges checks if the repository has any uncommitted changes
func HasChanges(dir string) (bool, error) <span class="cov8" title="6">{
        output, err := RunGitCommand(dir, "status", "--porcelain")
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>
        <span class="cov7" title="5">return len(output) &gt; 0, nil</span>
}

// BranchExists checks if a branch exists in the repository
func BranchExists(dir string, branch string) bool <span class="cov7" title="4">{
        cmd := exec.Command("git", "rev-parse", "--verify", branch)
        cmd.Dir = dir
        return cmd.Run() == nil
}</span>

// CreateAndCheckoutBranch creates and checks out a new branch
func CreateAndCheckoutBranch(dir string, branch string) error <span class="cov1" title="1">{
        cmd := exec.Command("git", "checkout", "-b", branch)
        cmd.Dir = dir
        return cmd.Run()
}</span>

// AddAllChanges stages all changes in the repository
func AddAllChanges(dir string) error <span class="cov1" title="1">{
        cmd := exec.Command("git", "add", "-A")
        cmd.Dir = dir
        return cmd.Run()
}</span>

// CommitChanges commits staged changes with the given message
func CommitChanges(dir string, message string) error <span class="cov1" title="1">{
        cmd := exec.Command("git", "commit", "-m", message)
        cmd.Dir = dir
        return cmd.Run()
}</span>

// PushBranch pushes a branch to the remote repository
func PushBranch(dir string, branch string) error <span class="cov1" title="1">{
        cmd := exec.Command("git", "push", "--set-upstream", "origin", branch)
        cmd.Dir = dir
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package git

import (
        "fmt"
        "os"

        "github.com/codcod/repos/internal/config"
        "github.com/codcod/repos/internal/util"
)

// RemoveRepository removes a cloned repository
func RemoveRepository(repo config.Repository) error <span class="cov10" title="10">{
        // Determine repository directory
        repoDir := util.GetRepoDir(repo)

        // Check if directory exists
        if _, err := os.Stat(repoDir); os.IsNotExist(err) </span><span class="cov3" title="2">{
                return fmt.Errorf("repository directory does not exist: %s", repoDir)
        }</span>

        // Check if it's a git repository
        <span class="cov9" title="8">if !util.IsGitRepository(repoDir) </span><span class="cov1" title="1">{
                return fmt.Errorf("not a git repository: %s", repoDir)
        }</span>

        // Remove the directory
        <span class="cov8" title="7">if err := os.RemoveAll(repoDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove repository: %w", err)
        }</span>

        <span class="cov8" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package github

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "os"

        "github.com/codcod/repos/internal/config"
        "github.com/codcod/repos/internal/git"
        "github.com/codcod/repos/internal/util"
)

// PROptions configures how the pull request is created
type PROptions struct {
        Title      string
        Body       string
        BaseBranch string
        BranchName string
        CommitMsg  string
        Draft      bool
        Token      string // GitHub API token
        CreateOnly bool   // Only create PR, don't make changes
}

// CreatePullRequest creates a PR for changes in the repository
func CreatePullRequest(repo config.Repository, options PROptions) error <span class="cov10" title="3">{
        logger := util.NewLogger()

        // Determine repository directory
        repoDir := util.GetRepoDir(repo)

        // Check if directory exists
        if _, err := os.Stat(repoDir); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return fmt.Errorf("repository directory does not exist: %s", repoDir)
        }</span>

        // Change to repository directory for Git operations
        <span class="cov6" title="2">originalDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %w", err)
        }</span>
        <span class="cov6" title="2">defer func() </span><span class="cov6" title="2">{
                // Ensure we always change back to the original directory
                if err := os.Chdir(originalDir); err != nil </span><span class="cov0" title="0">{
                        logger.Error(repo, "Failed to change back to original directory: %v", err)
                }</span>
        }()

        <span class="cov6" title="2">if err := os.Chdir(repoDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change to repository directory: %w", err)
        }</span>

        // Create changes unless "create only" mode is enabled
        <span class="cov6" title="2">if !options.CreateOnly </span><span class="cov1" title="1">{
                // Check for changes
                hasChanges, err := git.HasChanges(".") // Use "." instead of repoDir since we've already changed to that dir
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to check for changes: %w", err)
                }</span>

                <span class="cov0" title="0">if !hasChanges </span><span class="cov0" title="0">{
                        return fmt.Errorf("no changes detected in repository")
                }</span>

                // Create a new branch if one wasn't specified
                <span class="cov0" title="0">if options.BranchName == "" </span><span class="cov0" title="0">{
                        options.BranchName = fmt.Sprintf("automated-changes-%d", os.Getpid())
                }</span>

                // Create and checkout the branch
                <span class="cov0" title="0">if err := git.CreateAndCheckoutBranch(".", options.BranchName); err != nil </span><span class="cov0" title="0">{ // Use "." instead of repoDir
                        return fmt.Errorf("failed to create branch: %w", err)
                }</span>

                // Add all changes
                <span class="cov0" title="0">if err := git.AddAllChanges("."); err != nil </span><span class="cov0" title="0">{ // Use "." instead of repoDir
                        return fmt.Errorf("failed to add changes: %w", err)
                }</span>

                // Commit the changes
                <span class="cov0" title="0">commitMsg := options.CommitMsg
                if commitMsg == "" </span><span class="cov0" title="0">{
                        commitMsg = options.Title
                }</span>
                <span class="cov0" title="0">if commitMsg == "" </span><span class="cov0" title="0">{
                        commitMsg = "Automated changes"
                }</span>

                <span class="cov0" title="0">if err := git.CommitChanges(".", commitMsg); err != nil </span><span class="cov0" title="0">{ // Use "." instead of repoDir
                        return fmt.Errorf("failed to commit changes: %w", err)
                }</span>

                // Push the branch
                <span class="cov0" title="0">if err := git.PushBranch(".", options.BranchName); err != nil </span><span class="cov0" title="0">{ // Use "." instead of repoDir
                        return fmt.Errorf("failed to push branch: %w", err)
                }</span>
        }

        // Extract owner and repo name from URL
        <span class="cov1" title="1">owner, repoName, err := util.ExtractOwnerAndRepo(repo.URL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract owner and repo: %w", err)
        }</span>

        // Determine base branch if not specified
        <span class="cov1" title="1">baseBranch := options.BaseBranch
        if baseBranch == "" </span><span class="cov1" title="1">{
                // Default to 'main' if not specified
                baseBranch = "main"

                // Check if 'main' exists, otherwise use 'master'
                if !git.BranchExists(".", baseBranch) &amp;&amp; git.BranchExists(".", "master") </span><span class="cov0" title="0">{ // Use "." instead of repoDir
                        baseBranch = "master"
                }</span>
        }

        // Create the PR
        <span class="cov1" title="1">return createGitHubPullRequest(owner, repoName, options, baseBranch)</span>
}

// createGitHubPullRequestFunc is the function type for creating GitHub pull requests
type createGitHubPullRequestFunc func(owner, repo string, options PROptions, baseBranch string) error

// createGitHubPullRequest is a variable that can be overridden for testing
var createGitHubPullRequest createGitHubPullRequestFunc = createGitHubPullRequestImpl

// createGitHubPullRequestImpl creates a pull request via the GitHub API
func createGitHubPullRequestImpl(owner, repo string, options PROptions, baseBranch string) error <span class="cov1" title="1">{
        // GitHub API endpoint
        url := fmt.Sprintf("https://api.github.com/repos/%s/%s/pulls", owner, repo)

        // Check if token is provided
        if options.Token == "" </span><span class="cov1" title="1">{
                options.Token = os.Getenv("GITHUB_TOKEN")
                if options.Token == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("GitHub token not provided and GITHUB_TOKEN environment variable not set")
                }</span>
        }

        // Create PR request body
        <span class="cov0" title="0">data := map[string]interface{}{
                "title": options.Title,
                "body":  options.Body,
                "head":  options.BranchName,
                "base":  baseBranch,
                "draft": options.Draft,
        }

        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Accept", "application/vnd.github.v3+json")
        req.Header.Set("Authorization", "token "+options.Token)
        req.Header.Set("Content-Type", "application/json")

        // Send request
        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response
        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                var errorResponse map[string]interface{}
                if err := json.NewDecoder(resp.Body).Decode(&amp;errorResponse); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create PR, status: %d", resp.StatusCode)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create PR: %v", errorResponse)</span>
        }

        // Decode response
        <span class="cov0" title="0">var prResponse map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;prResponse); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print PR URL
        <span class="cov0" title="0">fmt.Printf("Pull request created: %s\n", prResponse["html_url"])
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package runner

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "sync"
        "time"

        "github.com/codcod/repos/internal/config"
        "github.com/codcod/repos/internal/util"
        "github.com/fatih/color"
)

// OutputProcessor handles processing of command output
type OutputProcessor struct {
        RepoName  string
        LogFile   *os.File
        IsStderr  bool
        HeaderSet bool
}

// ProcessOutput reads from the given reader and processes the output
func (p *OutputProcessor) ProcessOutput(reader io.Reader, wg *sync.WaitGroup) <span class="cov10" title="12">{
        defer wg.Done()

        scanner := bufio.NewScanner(reader)

        // Choose color based on output type
        var repoColor func(a ...interface{}) string
        if p.IsStderr </span><span class="cov7" title="6">{
                repoColor = color.New(color.FgRed, color.Bold).SprintFunc()
        }</span> else<span class="cov7" title="6"> {
                repoColor = color.New(color.FgCyan).SprintFunc()
        }</span>

        <span class="cov10" title="12">for scanner.Scan() </span><span class="cov6" title="4">{
                line := scanner.Text()

                // Print to stdout/stderr with colored repo name
                if p.IsStderr </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%s | %s\n", repoColor(p.RepoName), line)
                }</span> else<span class="cov6" title="4"> {
                        fmt.Printf("%s | %s\n", repoColor(p.RepoName), line)
                }</span>

                // Save to log file if enabled
                <span class="cov6" title="4">if p.LogFile != nil </span><span class="cov3" title="2">{
                        // Add stderr section header if needed
                        if p.IsStderr &amp;&amp; !p.HeaderSet </span><span class="cov0" title="0">{
                                p.LogFile.WriteString("\n=== STDERR ===\n")
                                p.HeaderSet = true
                        }</span>

                        <span class="cov3" title="2">p.LogFile.WriteString(fmt.Sprintf("%s | %s\n", p.RepoName, line))
                        p.LogFile.Sync()</span>
                }
        }
}

// PrepareLogFile creates and initializes a log file
func PrepareLogFile(repo config.Repository, logDir, command, repoDir string) (*os.File, string, error) <span class="cov9" title="10">{
        if logDir == "" </span><span class="cov6" title="5">{
                return nil, "", nil
        }</span>

        <span class="cov6" title="5">if err := util.EnsureDirectoryExists(logDir); err != nil </span><span class="cov1" title="1">{
                return nil, "", fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov6" title="4">logFilePath := filepath.Join(logDir, fmt.Sprintf("%s_%s.log",
                repo.Name,
                time.Now().Format("20060102_150405")))

        logFile, err := os.Create(logFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create log file: %w", err)
        }</span>

        // Write header information
        <span class="cov6" title="4">logFile.WriteString(fmt.Sprintf("Repository: %s\n", repo.Name))
        logFile.WriteString(fmt.Sprintf("Command: %s\n", command))
        logFile.WriteString(fmt.Sprintf("Directory: %s\n", repoDir))
        logFile.WriteString(fmt.Sprintf("Timestamp: %s\n\n", time.Now().Format(time.RFC3339)))
        logFile.WriteString("=== STDOUT ===\n")

        return logFile, logFilePath, nil</span>
}

// RunCommand runs a command in the repository directory
func RunCommand(repo config.Repository, command string, logDir string) error <span class="cov8" title="7">{
        logger := util.NewLogger()

        // Determine repository directory
        repoDir := util.GetRepoDir(repo)

        // Check if directory exists
        if _, err := os.Stat(repoDir); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return fmt.Errorf("repository directory does not exist: %s", repoDir)
        }</span>

        // Prepare command - use shell to properly handle quotes and complex commands
        <span class="cov7" title="6">cmd := exec.Command("sh", "-c", command)
        cmd.Dir = repoDir

        // Create pipes for stdout and stderr
        stdoutPipe, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>
        <span class="cov7" title="6">stderrPipe, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stderr pipe: %w", err)
        }</span>

        // Prepare log file
        <span class="cov7" title="6">logFile, logFilePath, err := PrepareLogFile(repo, logDir, command, repoDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="6">if logFile != nil </span><span class="cov3" title="2">{
                defer logFile.Close()
        }</span>

        // Run the command
        <span class="cov7" title="6">logger.Info(repo, "Running '%s'", command)

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start command: %w", err)
        }</span>

        // Set up wait group to ensure both stdout and stderr are fully processed
        <span class="cov7" title="6">var wg sync.WaitGroup
        wg.Add(2)

        // Process stdout and stderr in real-time
        stdoutProcessor := &amp;OutputProcessor{
                RepoName: repo.Name,
                LogFile:  logFile,
                IsStderr: false,
        }
        stderrProcessor := &amp;OutputProcessor{
                RepoName: repo.Name,
                LogFile:  logFile,
                IsStderr: true,
        }

        go stdoutProcessor.ProcessOutput(stdoutPipe, &amp;wg)
        go stderrProcessor.ProcessOutput(stderrPipe, &amp;wg)

        // Wait for both stdout and stderr to be fully processed
        wg.Wait()

        // Wait for the command to complete
        err = cmd.Wait()

        if logFile != nil &amp;&amp; err == nil </span><span class="cov3" title="2">{
                logger.Info(repo, "Log saved to %s", logFilePath)
        }</span>

        <span class="cov7" title="6">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("command failed: %w", err)
        }</span>

        <span class="cov6" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package util

import (
        "github.com/codcod/repos/internal/config"
        "github.com/fatih/color"
)

// Logger defines structured logging functions for repositories
type Logger struct {
        repoColor func(a ...interface{}) string
}

// NewLogger creates a new repository logger
func NewLogger() *Logger <span class="cov10" title="11">{
        return &amp;Logger{
                repoColor: color.New(color.FgCyan, color.Bold).SprintFunc(),
        }
}</span>

// Success logs a success message with standardized formatting
func (l *Logger) Success(repo config.Repository, format string, args ...interface{}) <span class="cov5" title="3">{
        color.Green("%s | "+format, append([]interface{}{l.repoColor(repo.Name)}, args...)...)
}</span>

// Error logs an error message with standardized formatting
func (l *Logger) Error(repo config.Repository, format string, args ...interface{}) <span class="cov1" title="1">{
        color.Red("%s | "+format, append([]interface{}{l.repoColor(repo.Name)}, args...)...)
}</span>

// Info logs an informational message with standardized formatting
func (l *Logger) Info(repo config.Repository, format string, args ...interface{}) <span class="cov7" title="6">{
        color.Cyan("%s | "+format, append([]interface{}{l.repoColor(repo.Name)}, args...)...)
}</span>

// Warn logs a warning message with standardized formatting
func (l *Logger) Warn(repo config.Repository, format string, args ...interface{}) <span class="cov1" title="1">{
        color.Yellow("%s | "+format, append([]interface{}{l.repoColor(repo.Name)}, args...)...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package util

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/codcod/repos/internal/config"
        "github.com/fatih/color"
)

// GetRepoDir returns the local directory for a repository
func GetRepoDir(repo config.Repository) string <span class="cov6" title="5">{
        if repo.Path != "" </span><span class="cov1" title="1">{
                return repo.Path
        }</span>
        <span class="cov5" title="4">dir := filepath.Base(repo.URL)
        return strings.TrimSuffix(dir, ".git")</span>
}

// IsGitRepository checks if the given directory is a git repository
func IsGitRepository(dir string) bool <span class="cov10" title="16">{
        gitDir := filepath.Join(dir, ".git")
        info, err := os.Stat(gitDir)
        return err == nil &amp;&amp; info.IsDir()
}</span>

// ExtractOwnerAndRepo extracts the owner and repository name from a GitHub URL
func ExtractOwnerAndRepo(url string) (owner string, repo string, err error) <span class="cov9" title="12">{
        // Handle SSH URLs: git@github.com:owner/repo.git
        if strings.HasPrefix(url, "git@github.com:") </span><span class="cov5" title="4">{
                path := strings.TrimPrefix(url, "git@github.com:")
                path = strings.TrimSuffix(path, ".git")
                parts := strings.Split(path, "/")
                if len(parts) != 2 </span><span class="cov1" title="1">{
                        return "", "", fmt.Errorf("invalid GitHub URL format: %s", url)
                }</span>
                <span class="cov4" title="3">return parts[0], parts[1], nil</span>
        }

        // Handle HTTPS URLs: https://github.com/owner/repo.git
        <span class="cov7" title="8">if strings.HasPrefix(url, "https://github.com/") </span><span class="cov4" title="3">{
                path := strings.TrimPrefix(url, "https://github.com/")
                path = strings.TrimSuffix(path, ".git")
                parts := strings.Split(path, "/")
                if len(parts) != 2 </span><span class="cov1" title="1">{
                        return "", "", fmt.Errorf("invalid GitHub URL format: %s", url)
                }</span>
                <span class="cov3" title="2">return parts[0], parts[1], nil</span>
        }

        <span class="cov6" title="5">return "", "", fmt.Errorf("unsupported URL format: %s", url)</span>
}

// ColoredRepoName returns the repository name formatted with the specified color
func ColoredRepoName(repo config.Repository, c *color.Color) string <span class="cov3" title="2">{
        return c.Sprint(repo.Name)
}</span>

// EnsureDirectoryExists ensures that a directory exists, creating it if necessary
func EnsureDirectoryExists(path string) error <span class="cov6" title="5">{
        return os.MkdirAll(path, 0755)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package util

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/codcod/repos/internal/config"
)

// FindGitRepositories recursively scans a directory for git repositories
func FindGitRepositories(rootPath string, maxDepth int) ([]config.Repository, error) <span class="cov5" title="8">{
        var repos []config.Repository

        err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="66">{
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                // Skip the root directory itself
                <span class="cov9" title="65">if path == rootPath </span><span class="cov4" title="7">{
                        return nil
                }</span>

                // Look for .git directory first
                <span class="cov9" title="58">if info.IsDir() &amp;&amp; info.Name() == ".git" </span><span class="cov6" title="18">{
                        repoPath := filepath.Dir(path)
                        
                        // Calculate repository depth (the depth of the repository directory itself)
                        repoRelPath, err := filepath.Rel(rootPath, repoPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        
                        <span class="cov6" title="18">repoDepth := 0
                        if repoRelPath != "." </span><span class="cov6" title="18">{
                                repoDepth = strings.Count(repoRelPath, string(os.PathSeparator)) + 1
                        }</span>
                        
                        // Only include repository if it's within the max depth
                        <span class="cov6" title="18">if maxDepth &gt; 0 &amp;&amp; repoDepth &gt; maxDepth </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        
                        <span class="cov6" title="18">repoName := filepath.Base(repoPath)

                        // Get remote URL
                        gitRemoteURL, _ := GetRemoteURL(repoPath)

                        // Skip if no remote URL found - but don't skip the directory, just continue
                        if gitRemoteURL == "" </span><span class="cov4" title="5">{
                                return nil
                        }</span>

                        // Create repository entry
                        <span class="cov6" title="13">repo := config.Repository{
                                Name: repoName,
                                URL:  gitRemoteURL,
                                Path: repoPath,
                                Tags: []string{"auto-discovered"},
                        }

                        repos = append(repos, repo)

                        // Skip deeper traversal of this directory
                        return filepath.SkipDir</span>
                }

                // Calculate current depth relative to root for non-.git directories
                <span class="cov8" title="40">relPath, err := filepath.Rel(rootPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Count directory separators to determine depth
                <span class="cov8" title="40">depth := 0
                if relPath != "." </span><span class="cov8" title="40">{
                        depth = strings.Count(relPath, string(os.PathSeparator)) + 1
                }</span>

                // Skip if we've exceeded max depth
                <span class="cov8" title="40">if maxDepth &gt; 0 &amp;&amp; depth &gt; maxDepth </span><span class="cov4" title="5">{
                        if info.IsDir() </span><span class="cov4" title="5">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov8" title="35">return nil</span>
        })

        <span class="cov5" title="8">return repos, err</span>
}

// GetRemoteURL retrieves the origin remote URL of a git repository
func GetRemoteURL(repoPath string) (string, error) <span class="cov7" title="25">{
        gitConfigPath := filepath.Join(repoPath, ".git", "config")

        data, err := os.ReadFile(gitConfigPath)
        if err != nil </span><span class="cov4" title="6">{
                return "", err
        }</span>

        <span class="cov6" title="19">content := string(data)
        lines := strings.Split(content, "\n")

        inOrigin := false
        for _, line := range lines </span><span class="cov10" title="90">{
                line = strings.TrimSpace(line)

                if line == "[remote \"origin\"]" </span><span class="cov6" title="16">{
                        inOrigin = true
                        continue</span>
                }

                <span class="cov9" title="74">if inOrigin &amp;&amp; strings.HasPrefix(line, "url = ") </span><span class="cov6" title="16">{
                        return strings.TrimPrefix(line, "url = "), nil
                }</span>

                // We're out of the origin section
                <span class="cov9" title="58">if inOrigin &amp;&amp; strings.HasPrefix(line, "[") </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="3">return "", nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
